# Занятие 4

## Рекап прошлого занятия

## Mutex

Синхронизация памяти очень важная задача. В современных компьютерах может быть множество процессов, каждый со своим локальным кешем основной памяти. Для оптимизации записи в память хранятся в буфере и применяются к памяти, только при необходимости. Это может произойти в разном порядке, чем было помещено в буфер горутиной.

Примитивы синхронизации, такие, как каналы или мьютексы, явно указывают на то, чтобы применить записи из буфера в память, для того, чтобы другие горутины при доступе к ним обладали этими данными.

Другими словами мьютексы используются для того, чтобы гарантировать, что с данными работает ровно одна горутина. Это актуально для таких типов данных, как:

- fkfakj

## Тестирование и бенчмаркинг

### Зачем вообще нужны тесты

1. Неопределенное поведение выявляется быстрее

   В ходе разработки, не всегда очевидно, какие корнеркейсы могут возникуть.
   Одновременное или последующее написание тестов позволяет взглянуть на код с консьюмерской перспективы: подумать о том, что будет, если какая-то переменная будет принимать такое-то значение. Это убирает многие неопределенности и потенциальные баги.
2. Написание лучшего кода

   Очень часто многие разработчики считают, что написание тестов это лишняя трата времени, в то время, как тесты позволяют критически отнестись к своему коду, поскольку наш мозг очень подвержен когнитивным искажениям, которые могут проникнуть в код, особенно связанный со сложными функциональностями.
3. Проектировании лучшей архитектуры

   В ходе разработки какого-то архитектурного решения с помощью тестов можно понять, верно ли были использованы абстракции и нужно ли что-то внести или убрать из под них.

   Интеграционные тесты позволяют сразу тестировать взаимодействие с другими сервисами, если для них существуют моковые реализации, это сразу решает проблему неверных контрактов между разными сервисами.
4. Проще проводить Bug Regression

   Bug regression - процесс в ходе которого тестируется воспроизводятся ли старые баге после фикса новых багов.

   Если в ходе исправления багов была задета функциональность, которую уже исправляли раньше, то тесты на кейсы старых багов помогут это задетектить и исправить до того, как релиз уйдет на прод.
5. Рефакторинг становится безопаснее

   да, не писать тексты довольно быстро, но как только нужно что-то изменить в уже существующем функционале, возникает вопрос, а не сломал ли я что-то своими изменениями? В таком случае наличие тестов поможет убедиться, что все поддерживаемые контракты не были затронуты и консьюмеры, зависящие он нашего функционала не сломаются.
6. Деплой происходит увереннее

   Если перед релизом не прогнать ни одного теста, можно услышать много новых и интересных слов о вас и вашем продукте от  клиентов)

   ### Как писать тесты в Golang

   В Go для написания тестов мы обычно создаем отдельный файл, название которого заканчивается на test. Внутри содержатся функции, названия которых начинаются на Test

   Допустим у нас есть файл math.go


   ```bash
   nano math.go

   ```

   ```go
   package math

   // Add is our function that sums two integers
   func Add(x, y int) (res int) {
   	return x + y
   }

   // Subtract subtracts two integers
   func Subtract(x, y int) (res int) {
   	return x - y
   }

   ```

Тогда создадим файл

```bash
nano math_test.go
```

```go
package math

import "testing"

func TestAdd(t *testing.T){

    got := Add(4, 6)
    want := 10

    if got != want {
        t.Errorf("got %q, wanted %q", got, want)
    }
}


```


### Пример с гонками


Бенчмаркинг

Пример простого бенчмарка из add

Пример обычной суммы и параллельной суммы с мьютексами
