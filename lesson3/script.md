# Занятие 3

Golang - это мощный язык параллельного программирования. Язык предоставляет разработчику такие инструменты, как goroutines и channels, которые дают нам возможность создавать параллельные приложения.

Goroutine - это облегченный поток, управляемый средой выполнения Go. При запуске его размер начинается с 2 КБ и может увеличиться до 1 ГБ.

каналы - это средства, с помощью которых различные программы взаимодействуют друг с другом.

Для передачи данных в канал или, наоборот, из канала применяется операция <- (направленная влево стрелка)

### Небуфферизированные каналы

Для создания небуферизированного канала вызывается функция `make()` без указания емкости канала:


Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные. Когда горутина-отправитель посылает данные, горутина-получатель получает эти данные и возобновляет работу.

Горутина-отправитель может отправлять данные только в пустой канал. Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены. Например:
```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int) 
     
    go func(){
            fmt.Println("Go routine starts")
            intCh <- 5 // блокировка, пока данные не будут получены функцией main
    }()
    fmt.Println(<-intCh) // получение данных из канала
    fmt.Println("The End")
}
```

Общий ход выполнения программы выглядит следующим образом:

1. Запускается функция main. Она создает канал intCh и запускает горутину в виде анонимной функции.
    
2. Функция main продолжает выполняться и блокируется на строке `fmt.Println(<-intCh)`, пока не будут получены данные.
    
3. Параллельно выполняется запущенная горутина в виде анонимной функции. В конце своего выполнения она отправляет даные через канал: `intCh <- 5`. Горутина блокируется, пока функция main не получит данные.
    
4. Функция main получает отправленные данные, деблокируется и продолжает свою работу.
    

В данном случае горутина определена в виде анонимной функции и поэтому она имеет доступ к окружению, в том числе к переменной intCh. Если же мы работаем с обычными функциями, то объекты каналов надо передавать через параметры:

```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int) 
     
    go factorial(5, intCh)  // вызов горутины
    fmt.Println(<-intCh) // получение данных из канала
    fmt.Println("The End")
}
 
func factorial(n int, ch chan int){
     
    result := 1
    for i := 1; i <= n; i++{
        result *= i
    }
    fmt.Println(n, "-", result)
     
    ch <- result     // отправка данных в канал
}
```

### Буферизированные каналы

Буферизированные каналы также создаются с помощью функции `make()`, только в качестве второго аргумента в функцию передается емкость канала. Если канал пуст, то получатель ждет, пока в канале появится хотя бы один элемент.

При отправке данных горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.

```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int, 3) 
    intCh <- 10
    intCh <- 3
    intCh <- 24
    fmt.Println(<-intCh)     // 10
    fmt.Println(<-intCh)     // 3
    fmt.Println(<-intCh)     //24
}
```

В данном случае отправителем и получателем данных является функция main. В ней создается канал из трех элементов, и последовательно отправляются три значения типа int.

В то же время в данном случае должно быть соответствие между количеством отправляемых и получаемых данных. Если в функции main будет одновременно отправлено значений больще, чем вмещает канал, то функция заблокируется:

```go
package main
import "fmt"
 
func main() {
     
    intCh := make(chan int, 3) 
    intCh <- 10
    intCh <- 3
    intCh <- 24
    intCh <- 15  // блокировка - функция main ждет, когда освободится место в канале
     
    fmt.Println(<-intCh)
    fmt.Println("The End")
}
```

## Открыть example1 и потом example2

### Mutex 

(сокращение от "mutual exclusion" - взаимное исключение) - это средство синхронизации, используемое в многопоточных приложениях для обеспечения взаимного исключения доступа к общим ресурсам. Mutex представляет собой блокировку, которая предотвращает одновременный доступ нескольких потоков (горутин) к общему ресурсу, пока один из них не завершит свою работу с этим ресурсом. Mutex - это ключевой инструмент для предотвращения гонок данных и обеспечения согласованности данных в параллельных приложениях.

Основные методы для работы с Mutex в языке Go находятся в пакете sync. Два наиболее часто используемых метода - Lock и Unlock:

    Lock: Этот метод блокирует Mutex, что означает, что другие потоки или горутины, пытающиеся заблокировать Mutex, будут ожидать, пока Mutex не будет разблокирован текущим потоком. Если Mutex уже заблокирован другим потоком, текущий поток будет заблокирован до тех пор, пока Mutex не освободится.

    Unlock: Этот метод разблокирует Mutex, позволяя другим потокам или горутинам блокировать его и получать доступ к общим ресурсам.
    
```go
package main

import (
    "fmt"
    "sync"
)

var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
    fmt.Printf("Counter: %d\n", counter)
}
```
### select
select - это конструкция в языке программирования Go, которая используется для работы с несколькими каналами и позволяет выбирать первый готовый канал для операции ввода или вывода. Она предоставляет механизм мультиплексирования ввода-вывода для горутин, позволяя им взаимодействовать с разными каналами асинхронно.

Основные черты select:

    Мультиплексирование каналов: select позволяет одновременно мониторить несколько каналов и выполнять операции чтения или записи на первом доступном канале. Это облегчает обработку множества каналов без необходимости явно создавать дополнительные горутины.

    Блокирующая операция: Если нет доступных операций на каналах, select заблокирует выполнение текущей горутины, ожидая, пока какая-либо из операций не станет доступной.

    Случай по умолчанию (default): Вы можете добавить случай по умолчанию в конструкцию select, который будет выполнен, если нет других готовых операций на каналах.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(2 * time.Second)
        ch1 <- "Channel 1: Hello"
    }()

    go func() {
        time.Sleep(1 * time.Second)
        ch2 <- "Channel 2: World"
    }()

    select {
    case msg1 := <-ch1:
        fmt.Println(msg1)
    case msg2 := <-ch2:
        fmt.Println(msg2)
    case <-time.After(3 * time.Second):
        fmt.Println("Timeout")
    }
}
```

## Паттерны канкаренси в Go
### Fan-IN
Если мы получаем данные из нескольких каналов, мы можем объединить их в один и вернуть его. Возможно, мы захотим перенаправить данные из нескольких источников в один поток.
![image](https://github.com/antonvlasov/teach/assets/80615643/fae74738-cb58-4462-aab1-2fb55e3cdc8b)
```go
// принимает на вход context и каналы любых типов доступных только для чтения
	func fanIn(ctx context.Context,fetchers ...<-chan any) chan any {
// канал который будет объеденять
	combinedFetchers := make(chan any)  
	wg := sync.WaitGroup{}  
	wg.Add(len(fetchers))  
	  
	for _, f := range fetchers {
	f := f  
	go func () {  
		defer wg.Done()  
		for{  
			select {  
				case res := <- f:  
					combinedFetchers <- res  
				case <- ctx.Done():  
					return  
			}  
		}  
		}()  
	}

	go func() {
		wg.Wait
		close(combinedFetchers)	
	} ()
	return combinedFetchers  
}
```

### Worker pool 
Этот паттерн позволяет эффективно использовать доступные вычислительные ресурсы и распределять задачи между рабочими единицами для ускорения выполнения.
![image](https://github.com/antonvlasov/teach/assets/80615643/35b01f79-994f-4d26-8d06-ab72fb4c0216)

Пример в файле example2.go

### ДОМАШКА:
Разработать конвейер чисел. Даны два канала: в первый пишутся числа (x) из массива,
 во второй — результат операции x*2, после чего данные из второго канала должны выводиться в stdout.
